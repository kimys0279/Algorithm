# 이상현상 & 정규화

### 이상현상(Anomaly)

좋은 관계형 데이터베이스를 설계하는 목적 중 하나가 정보의 **이상 현상(Anomaly)** 이 생기지 않도록 고려해 설계하는 것이다.

이상 현상이란? 테이블내의 **데이터 중복성에 의해서 발생되는 데이터 불일치 현상**이다.

이상 현상은 **갱신 이상(Modification Anomaly), 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly)**으로 구성된다. 

<br/>

#### 수강 테이블

| 학번 | 과목        | 이름   | 성적 |
| ---- | ----------- | ------ | ---- |
| 1000 | 알고리즘    | 김알고 | A    |
| 1001 | 자료 구조   | 박자료 | B    |
| 1000 | 자료 구조   | 김알고 | A    |
| 1002 | 컴퓨터 구조 | 이컴공 | C    |

<br/>

#### 갱신 이상

반복된 데이터 중에 일부를 갱신 할 시 데이터의 불일치가 발생한다.

위와 같은 <수강> 테이블이 있다고 하자. 

테이블의 기본 키는 (학번,과목)이다.

그런데 학번 1000의 김알고 학생이 개명해서 김컴공이 되었다. 

그렇다면 김알고 학생이 속해 있는 튜플을 찾아서 모두 김컴공으로 바꿔줘야 한다. 

그런데 첫 번째 튜플에서 김알고란 이름을 김컴공으로 바꾸게 된다면 세 번째 튜플과 학번은 같지만 다른 이름을 가진 학생이 되는 것이다. 

이는 데이터 불일치이므로 갱신 이상이 발생한다.

<br/>

#### 삽입 이상

불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능하다.

<수강> 테이블에 학번 1003의 네트워크 수업을 듣는 최네트 학생을 삽입하고 싶다. 

그러나 아직 성적이 결정되지 않았다. 

따라서 성적 정보를 넣지 않고서는 수강 테이블에 저장하는 것은 불가능하다.

<br/>

#### 삭제 이상

필요한 정보를 함께 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능하다.

<수강> 테이블에서 이컴공 학생의 컴퓨터 구조 성적을 삭제하고 싶다. 

하지만 성적만 삭제하는 것은 불가능하기에 이컴공 학생과 관련한 정보(튜플)가 모두 사라진다.

<br/>

**따라서 위와 같은 이상현상을 없애기 위해 정규화를 해야 한다.**

<br/>

### 정규화(Normalization)란?

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 **정규화(Normalization)**라고 한다. 

데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다. 일반적으로 정규화란 크고, 제대로 조직되지 않은 테이블들과 관계들을 작고 잘 조직된 테이블과 관계들로 나누는 것을 포함한다. 

정규화의 목적은 하나의 테이블에서의 데이터의 삽입, 삭제, 변경이 정의된 관계들로 인하여 데이터베이스의 나머지 부분들로 전파되게 하는 것이다.



### 정규화의 목적

- 불필요한 데이터를 제거, 데이터의 중복을 최소화 하기 위해서
- 데이터베이스 구조 확장 시 재디자인을 최소화
- 다양한 관점에서의 query를 지원하기 위해서
- 무결성 제약조건의 시행을 간단하게 하기 위해서
- 각종 이상 현상(Anomaly) 을 방지하기 위해서, 테이블의 구성을 논리적이고 직관적으로 한다.





### 정규화 단계



정규화는 6단계로 이루어져 있다. 

제 1정규형, 제 2정규형, 제 3정규형, BC정규형, 제 4정규형, 제 5정규형이다.

각 단계는 이전의 모든 단계의 조건을 만족시켜야 한다. 



#### 제 1 정규형 (1NF)

정의 상, 제1 정규형을 만족한 것이 관계형 테이블이다.

모든 속성 값은 원자 값으로만 구성된다.

> 원자 값이란?
>
> 더 이상 쪼개지지 않는 단위

| 학번 | 과목                         | 성명   | 성적    |
| ---- | ---------------------------- | ------ | ------- |
| 1000 | 알고리즘, 자료구조, 네트워크 | 김알고 | A+,B+,C |

> 수강 릴레이션을 다시 보자.

위의 테이블은 과목과 성적 컬럼은 세 개의 속성 값을 가진다. 이러한 형태는 제 1 정규형을 만족하지 않는다. 따라서

| <u>학번</u> | <u>과목</u> | 성명   | 성적 |
| ----------- | ----------- | ------ | ---- |
| 1000        | 알고리즘    | 김알고 | A+   |
| 1000        | 자료구조    | 김알고 | B+   |
| 1000        | 네트워크    | 김알고 | C    |

다음과 같이 원자 값으로 바꾼다면 제 1 정규형을 만족하는 것이다.

그러나 갱신,삽입, 삭제 이상현상은 여전히 발생한다.

<br/>



#### 제 2 정규형 (2NF)

제 2정규형을 이해하기 위한 '함수적 종속성'이라는 단어에 대해 알아보자. 

<br/>

> 함수적 종속성(Functional Dependency)
>
> **함수 종속**(functional dependency)이란 데이터베이스의 릴레이션(relation)에서 두 개의 애트리뷰트(attribute) 집합 간 제약의 일종이다.
>
> 어떤 릴레이션 **R**에서, **X**와 **Y**를 각각 **R**의 속성 집합의 부분 집합이라 하자. 애트리뷰트 **X**의 값 각각에 대해 항상 애트리뷰트 **Y**의 값이 오직 하나만 연관되어 있을 때 **Y**는 **X**에 **함수 종속**이라 하고, **X** → **Y**라고 표기한다. 
>
> 다시 말해, **R** 내의 속성 집합 **X**와 역시 **R** 내에 있는 또 다른 애트리뷰트의 집합 **Y**에 대해, 각각의 **X** 값에 대해 최대 한 개의 **Y** 값에 연관되어 있을 때, 애트리뷰트의 집합 **X**를 **함수 결정**(to functionally determine)하다고 한다.
>
> **X**를 **결정자**(determinant set)이라 하고, **Y**를 **종속자**(dependent attribute)라고 한다.

<br/>

함수적 종속성을 이해했다면 제 2 정규형을 알아보자.

<br/>

제 2정규형은 모든 컬럼이 완전종속관계를 가지는 것을 말한다.  (부분 함수 종속성 => 완전 함수 종속성)

>  완전종속관계란? 
>
> 후보키를 X라 하고 X에 속하지 않는 속성을 Y라 할 때, Y를 결정하기 위해서는 X의 일부가 아니라 전체를 참조해야 한다는 것이다.

<br/>

**???** 

<img src="./img/normal_img_1.jpg" alt="relation" style="zoom: 100%;" />



단어만 보고는 무슨 말인지 모르겠으니 사례를 통해 이해해보자.

> 수강 테이블을 다시 보자.

| <u>학번</u> | <u>과목</u> | 성명   | 성적 |
| ----------- | ----------- | ------ | ---- |
| 1000        | 알고리즘    | 김알고 | A+   |
| 1000        | 자료구조    | 김알고 | B+   |
| 1000        | 네트워크    | 김알고 | C    |
| 1001        | 알고리즘    | 박자료 | B+   |
| 1001        | 자료구조    | 박자료 | A+   |
| 1002        | 알고리즘    | 이컴공 | D    |

수강 테이블은 (학번,과목)를 후보키로 가지고 있다. 

그런데 성명 속성은 (학번,과목)뿐만 아니라 **학번 속성만으로도 구분이 가능**하다. 

따라서 **성명 속성은 부분적 함수 종속관계**를 가지고 있다. 

그러므로 제 2정규형을 만족시키기 위해서는 이를 완전 함수 종속관계로 변화시켜야 한다.

<br/>

| <u>학번</u> | 성명   |
| ----------- | ------ |
| 1000        | 김알고 |
| 1001        | 박자료 |
| 1002        | 이컴공 |

| <u>학번</u> | 과목     | 성적 |
| ----------- | -------- | ---- |
| 1000        | 알고리즘 | A+   |
| 1000        | 자료구조 | B+   |
| 1000        | 네트워크 | C    |
| 1001        | 알고리즘 | B+   |
| 1001        | 자료구조 | A+   |
| 1002        | 알고리즘 | D    |



다음과 같이 두 개의 테이블로 분리하면 제 2정규형을 만족시킨다.

<br/>

<br/>

#### 제 3정규형 (3NF)

제 3정규형의 정의는 

- 릴레이션 R (테이블)은 제2정규형이다.
- 릴레이션 R의 키가 아닌 모든 컬럼이 릴레이션 R의 모든 키에 이행적 종속이 되지 않는다.



또, 골치 아픈 단어가 나왔다. 이행적 함수 종속...

> 이행적 함수 종속은 
>
> X -> Y 이고 Y -> Z에 의해서 X -> Z가 되는 것이다.

역시 무슨 말인지 모르겠으니 사례를 보자.



**<예제>**

알고리즘 대회가 열렸다.

대회 우승자 테이블이다.

| <u>대회</u>     | <u>연도</u> | 우승자 아이디 | 우승자 이름 |
| --------------- | ----------- | ------------- | ----------- |
| 카카오 블라인드 | 2018        | Ryan          | 라이언      |
| 카카오 코드     | 2018        | Apeach        | 어피치      |
| SCPC            | 2019        | Muzi          | 무지        |
| 카카오 블라인드 | 2019        | Apeach        | 어피치      |
| 카카오 블라인드 | 2020        | Ryan          | 라이언      |

대회 우승자 테이블은 (대회, 연도)를 후보 키로 가진다. 

>  (대회,연도) -> 우승자 아이디
>
> (대회,연도) -> 우승자 이름
>
> 이라는 함수 종속성을 가진다.

그런데 자세히 보면 **우승자의 이름은 우승자 아이디로 인해 결정**된다.

즉 (대회,연도) -> 우승자 아이디 -> 우승자 이름 이라는 함수 종속성이 발생하여

(대회,연도) - > 우승자 이름이라는 이행적 함수 종속성이 발생한다. 

따라서 이행적 함수 종속성을 해결해보자.

| <u>우승자 아이디</u> | 우승자 이름 |
| -------------------- | ----------- |
| Ryan                 | 라이언      |
| Apeach               | 어피치      |
| Muzi                 | 무지        |

| <u>대회</u>     | <u>연도</u> | 우승자 아이디 |
| --------------- | ----------- | ------------- |
| 카카오 블라인드 | 2018        | Ryan          |
| 카카오 코드     | 2018        | Apeach        |
| SCPC            | 2019        | Muzi          |
| 카카오 블라인드 | 2019        | Apeach        |
| 카카오 블라인드 | 2020        | Ryan          |

위와 같이 테이블을 분리하여 제 3정규형을 만족시킨다.

<br/>

<br/>

#### 보이스 코드 정규형 (Boyce-Codd NF)



보이스코드 정규형(이하 BCNF)는 제 3정규형을 만족시킨다.

대부분의 경우 3NF을 만족시킨 테이블은 BCNF도 만족시킨다. 

다만 여러 후보 키가 있는 3NF 테이블이라면 BCNF를 만족시키지 않을 수 있다.

BCNF의 조건은

- X-> Y가 Trivial Functional Dependency이거나
- X가 릴레이션 R의 슈퍼키이어야 한다.

> Trivial Functional Dependency
>
> 만약 Y가 X의 하위 집합이라면 X → Y 가 True 인 것은 명확하며, 이러한 종류의 의존성을 "Trivial" 이라 부른다. 다른 모든 의존성들은 덜 명확하며, "Nontrivial" 이라 부른다.

??? 쉽게 설명하자면 결정자는 후보키이어야 한다는 것이다. (이것도 무슨 소리인지 모르겠다면 예제를 보자.)



**예제**

| 학생 성명 | 과목        | 과목 담당 교수 |
| --------- | ----------- | -------------- |
| 김알고    | 알고리즘    | 다익스트라     |
| 김알고    | 컴퓨터 구조 | 앨런 튜링      |
| 박자료    | 머신러닝    | 앤드류 응      |
| 이컴공    | 알고리즘    | 다익스트라     |

> 교수는 하나의 과목만 맡을 수 있다고 가정한다.

다음과 같은 테이블에서는 (학생 성명, 과목) or (학생 성명, 과목 담당 교수)가 후보키이다. 

그런데 만약 (학생 성명, 과목)을 후보 키로 정한다면? 

과목은 과목 담당 교수에 의해 정해지는 종속자이다. 과목 담당 교수는 결정자다. 

그렇다면 이는 BCNF를 만족시키지 못한다. 

따라서 이를 다음과 같이 두 개의 테이블로 분리할 수 있다.

| 학생 성명 | 과목        |
| --------- | ----------- |
| 김알고    | 알고리즘    |
| 김알고    | 컴퓨터 구조 |
| 박자료    | 머신러닝    |
| 이컴공    | 알고리즘    |

| 과목        | 과목 담당 교수 |
| ----------- | -------------- |
| 알고리즘    | 다익스트라     |
| 컴퓨터 구조 | 앨런 튜링      |
| 머신러닝    | 앤드류 응      |

<br/>

<br/>





### 역정규화(DeNormalization)

**역정규화 = 반정규화**

#### 역정규화(반정규화)란?

반정규화(=역정규화) 용어는 조금 다르게 표현되어도 그 의미는 동일하다. 

여기에서 반정규화는 ‘반(Half)’의 의미가 아닌 한자로 반대하다의 의미를 가진 ‘反’의 의미이다. 영어로는 De-Normalization이다. 비정규화는 아예 정규화를 수행하지 않은 모델을 지칭할 때 사용한다.

반정규화를 정의하면 정규화된 엔터티, 속성, 관계에 대해 **시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미**한다. 

> 협의의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 
>
> 좀 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다.

데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 

**데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.**

![img](http://www.dbguide.net/publishing/img/knowledge/SQL_089.jpg)

기본적으로 정규화는 입력/수정/삭제에 대한 성능을 향상시킬 뿐만 아니라 조회에 대해서도 성능을 향상시키는 역할을 한다. 

그러나 **정규화만을 수행하면 엔터티의 갯수가 증가하고 관계가 많아져 일부 여러 개의 조인이 걸려야만 데이터를 가져오는 경우**가 있다. 

또한 **정규화의 함수적 종속관계는 위반하지 않지만 데이터의 중복성을 증가시켜야만 데이터조회의 성능을 향상시키는 경우**가 있다. 

프로젝트에서는 설계단계에서 반정규화를 적용하게 되는데 반정규화를 기술적으로 수행하지 않는 경우에는 다음과 같은 현상이 발생된다.

- 성능이 저하된 데이터베이스가 생성될 수 있다.
- 구축단계나 시험단계에서 반정규화를 적용할 때 수정에 따른 노력비용이 많이 들게 된다.

<br/>

####  정규화가 잘 정의된 데이터 모델에서 성능이 저하될 수 있는 경우

[그림 Ⅰ-2-14]는 공급자라고 하는 엔터티가 마스터이고 전화번호와 메일주소 위치가 각각 변경되는 내용이 이력형태로 관리되는 데이터 모델이다. 이 모델에서 공급자정보를 가져오는 경우를 가정해 보자.

![img](http://www.dbguide.net/publishing/img/knowledge/SQL_094.jpg)

공급자와 전화번호, 메일주소, 위치는 1:M 관계이므로 한 명의 공급자당 여러 개의 전화번호, 메일주소, 위치가 존재한다. 따라서 가장 최근에 변경된 값을 가져오기 위해서는 조금 복잡한 조인이 발생될 수 밖에 없다.

정규화 된 모델이 적절하게 반정규화 되지 않으면 복잡한 SQL구문은 쉽게 나올 수 있다. 

위의 모델을 적절하게 반정규화를 적용하면 즉, 가장 최근에 변경된 값을 마스터에 위치시키면 아주 간단한 SQL구문이 작성 된다.

![img](http://www.dbguide.net/publishing/img/knowledge/SQL_096.jpg)
![img](http://www.dbguide.net/publishing/img/knowledge/SQL_097.jpg)

위에서 복잡하게 작성된 SQL문장이 반정규화를 적용하므로 인해 다음과 같이 간단하게 작성이 되어 가독성도 높아지고 성능도 향상되어 나타났다.

```sql
SELECT 공급자명, 전화번호, 메일주소, 위치 FROM 공급자 WHERE 공급자번호 BETWEEN '1001' AND '1005'
```

<br/>

<br/>





### REFERENCE

[위키백과 - 정규화](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94)

[위키백과 - 역정규화](https://ko.wikipedia.org/wiki/역정규화)

[야붕 - BCNF](https://yaboong.github.io/database/2018/03/10/database-normalization-2/)

[꽁담 - 데이터베이스 정규화 알아보기](https://mozi.tistory.com/110)

[Wikipedia - BCNF](https://en.wikipedia.org/wiki/Boyce–Codd_normal_form)

[DBGUIDE - 반정규화와 성능](http://www.dbguide.net/db.db?cmd=view&boardUid=148185&boardConfigUid=9&categoryUid=216&boardIdx=133&boardStep=1)